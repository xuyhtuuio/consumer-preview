(function (global, factory) { typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(global) : typeof define === 'function' && define.amd ? define(factory) : factory(global) }((typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : this), (global) => {
  global = global || {}; const _Base64 = global.Base64; const version = '2.6.3'; const b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'; const b64tab = (function (bin) { const t = {}; for (let i = 0, l = bin.length; i < l; i++) { t[bin.charAt(i)] = i } return t }(b64chars)); const { fromCharCode } = String; const cb_utob = function (c) { if (c.length < 2) { var cc = c.charCodeAt(0); return cc < 128 ? c : cc < 2048 ? (fromCharCode(192 | (cc >>> 6)) + fromCharCode(128 | (cc & 63))) : (fromCharCode(224 | ((cc >>> 12) & 15)) + fromCharCode(128 | ((cc >>> 6) & 63)) + fromCharCode(128 | (cc & 63))) } else { var cc = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320); return (fromCharCode(240 | ((cc >>> 18) & 7)) + fromCharCode(128 | ((cc >>> 12) & 63)) + fromCharCode(128 | ((cc >>> 6) & 63)) + fromCharCode(128 | (cc & 63))) } }; const re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g; const utob = function (u) { return u.replace(re_utob, cb_utob) }; const cb_encode = function (ccc) {
    const padlen = [0, 2, 1][ccc.length % 3]; const ord = ccc.charCodeAt(0) << 16 | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8) | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0)); const
      chars = [b64chars.charAt(ord >>> 18), b64chars.charAt((ord >>> 12) & 63), padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63), padlen >= 1 ? '=' : b64chars.charAt(ord & 63)]; return chars.join('')
  }; const btoa = global.btoa && typeof global.btoa === 'function' ? function (b) { return global.btoa(b) } : function (b) { if (b.match(/[^\x00-\xFF]/)) { throw new RangeError('The string contains invalid characters.') } return b.replace(/[\s\S]{1,3}/g, cb_encode) }; const _encode = function (u) { return btoa(utob(String(u))) }; const mkUriSafe = function (b64) { return b64.replace(/[+\/]/g, (m0) => { return m0 == '+' ? '-' : '_' }).replace(/=/g, '') }; const encode = function (u, urisafe) { return urisafe ? mkUriSafe(_encode(u)) : _encode(u) }; const encodeURI = function (u) { return encode(u, true) }; let fromUint8Array; if (global.Uint8Array) {
    fromUint8Array = function (a, urisafe) {
      let b64 = ''; for (let i = 0, l = a.length; i < l; i += 3) {
        const a0 = a[i]; const a1 = a[i + 1]; const
          a2 = a[i + 2]; const ord = a0 << 16 | a1 << 8 | a2; b64 += b64chars.charAt(ord >>> 18) + b64chars.charAt((ord >>> 12) & 63) + (typeof a1 !== 'undefined' ? b64chars.charAt((ord >>> 6) & 63) : '=') + (typeof a2 !== 'undefined' ? b64chars.charAt(ord & 63) : '=')
      } return urisafe ? mkUriSafe(b64) : b64
    }
  } const re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g; const cb_btou = function (cccc) {
    switch (cccc.length) {
      case 4: var cp = ((7 & cccc.charCodeAt(0)) << 18) | ((63 & cccc.charCodeAt(1)) << 12) | ((63 & cccc.charCodeAt(2)) << 6) | (63 & cccc.charCodeAt(3)); var
        offset = cp - 65536; return (fromCharCode((offset >>> 10) + 55296) + fromCharCode((offset & 1023) + 56320)); case 3: return fromCharCode(((15 & cccc.charCodeAt(0)) << 12) | ((63 & cccc.charCodeAt(1)) << 6) | (63 & cccc.charCodeAt(2))); default: return fromCharCode(((31 & cccc.charCodeAt(0)) << 6) | (63 & cccc.charCodeAt(1)))
    }
  }; const btou = function (b) { return b.replace(re_btou, cb_btou) }; const cb_decode = function (cccc) {
    const len = cccc.length; const padlen = len % 4; const n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0) | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0) | (len > 2 ? b64tab[cccc.charAt(2)] << 6 : 0) | (len > 3 ? b64tab[cccc.charAt(3)] : 0); const
      chars = [fromCharCode(n >>> 16), fromCharCode((n >>> 8) & 255), fromCharCode(n & 255)]; chars.length -= [0, 0, 2, 1][padlen]; return chars.join('')
  }; const _atob = global.atob && typeof global.atob === 'function' ? function (a) { return global.atob(a) } : function (a) { return a.replace(/\S{1,4}/g, cb_decode) }; const atob = function (a) { return _atob(String(a).replace(/[^A-Za-z0-9\+\/]/g, '')) }; const _decode = function (a) { return btou(_atob(a)) }; const _fromURI = function (a) { return String(a).replace(/[-_]/g, (m0) => { return m0 == '-' ? '+' : '/' }).replace(/[^A-Za-z0-9\+\/]/g, '') }; const decode = function (a) { return _decode(_fromURI(a)) }; let toUint8Array; if (global.Uint8Array) { toUint8Array = function (a) { return Uint8Array.from(atob(_fromURI(a)), (c) => { return c.charCodeAt(0) }) } } const noConflict = function () { const { Base64 } = global; global.Base64 = _Base64; return Base64 }; global.Base64 = { VERSION: version, atob, btoa, fromBase64: decode, toBase64: encode, utob, encode, encodeURI, btou, decode, noConflict, fromUint8Array, toUint8Array }; if (typeof Object.defineProperty === 'function') { const noEnum = function (v) { return { value: v, enumerable: false, writable: true, configurable: true } }; global.Base64.extendString = function () { Object.defineProperty(String.prototype, 'fromBase64', noEnum(function () { return decode(this) })); Object.defineProperty(String.prototype, 'toBase64', noEnum(function (urisafe) { return encode(this, urisafe) })); Object.defineProperty(String.prototype, 'toBase64URI', noEnum(function () { return encode(this, true) })) } } if (global['Meteor']) { Base64 = global.Base64 } if (typeof module !== 'undefined' && module.exports) { module.exports.Base64 = global.Base64 } else if (typeof define === 'function' && define.amd) { define([], () => { return global.Base64 }) } return { Base64: global.Base64 }
}));
